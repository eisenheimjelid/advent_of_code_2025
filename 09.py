"""ğŸ„ Solution for Day 9 of Advent of Code 2025 ğŸ„

Usage:

uv run adventofcode run 09.py
"""

from dataclasses import dataclass
from bisect import bisect
from typing import NamedTuple
from itertools import combinations, pairwise, chain
from collections import defaultdict

inp = """97813,50305
97813,51516
97783,51516
97783,52726
97723,52726
97723,53925
97529,53925
97529,55124
97383,55124
97383,56376
97639,56376
97639,57596
97555,57596
97555,58689
96759,58689
96759,60060
97414,60060
97414,61189
96856,61189
96856,62354
96490,62354
96490,63466
95949,63466
95949,64751
95985,64751
95985,65812
95312,65812
95312,66989
94987,66989
94987,68037
94332,68037
94332,69127
93798,69127
93798,70242
93324,70242
93324,71482
93096,71482
93096,72495
92402,72495
92402,73478
91670,73478
91670,74710
91370,74710
91370,75506
90344,75506
90344,76548
89728,76548
89728,77514
88997,77514
88997,78864
88786,78864
88786,79393
87475,79393
87475,80380
86776,80380
86776,81370
86073,81370
86073,82288
85282,82288
85282,83613
84912,83613
84912,83898
83467,83898
83467,84711
82575,84711
82575,85781
81914,85781
81914,86670
81076,86670
81076,87284
80007,87284
80007,88497
79407,88497
79407,89236
78427,89236
78427,89627
77207,89627
77207,90199
76126,90199
76126,91291
75372,91291
75372,91401
74016,91401
74016,91983
72952,91983
72952,92251
71727,92251
71727,93516
71001,93516
71001,93679
69732,93679
69732,94022
68559,94022
68559,95078
67673,95078
67673,94873
66293,94873
66293,95377
65187,95377
65187,95478
63950,95478
63950,96455
62972,96455
62972,96602
61748,96602
61748,96579
60495,96579
60495,97372
59420,97372
59420,97691
58233,97691
58233,97735
57000,97735
57000,98001
55801,98001
55801,97591
54532,97591
54532,98041
53349,98041
53349,97790
52117,97790
52117,98141
50912,98141
50912,97902
49693,97902
49693,97770
48483,97770
48483,98135
47250,98135
47250,97667
46063,97667
46063,97599
44852,97599
44852,97538
43636,97538
43636,97004
42491,97004
42491,97602
41153,97602
41153,97327
39958,97327
39958,96847
38812,96847
38812,96442
37658,96442
37658,96120
36483,96120
36483,95254
35482,95254
35482,95468
34133,95468
34133,95012
33001,95012
33001,94106
32054,94106
32054,93769
30884,93769
30884,93651
29604,93651
29604,92861
28634,92861
28634,92406
27502,92406
27502,91998
26336,91998
26336,91169
25409,91169
25409,90232
24564,90232
24564,90177
23150,90177
23150,89560
22088,89560
22088,88650
21236,88650
21236,88118
20102,88118
20102,86741
19648,86741
19648,86162
18552,86162
18552,85221
17767,85221
17767,84875
16421,84875
16421,83824
15740,83824
15740,82993
14843,82993
14843,81945
14183,81945
14183,80857
13587,80857
13587,80371
12262,80371
12262,79424
11480,79424
11480,78153
11142,78153
11142,76942
10758,76942
10758,76346
9462,76346
9462,75317
8797,75317
8797,74285
8134,74285
8134,73099
7748,73099
7748,71829
7551,71829
7551,70968
6553,70968
6553,69730
6324,69730
6324,68735
5558,68735
5558,67351
5741,67351
5741,66220
5328,66220
5328,65210
4554,65210
4554,64094
4051,64094
4051,62798
4165,62798
4165,61656
3764,61656
3764,60576
3060,60576
3060,59449
2481,59449
2481,58187
2574,58187
2574,56960
2538,56960
2538,55715
2716,55715
2716,54590
1802,54590
1802,53347
1991,53347
1991,52121
2114,52121
2114,50911
1916,50911
1916,50285
94619,50285
94619,48466
1668,48466
1668,47274
2282,47274
2282,46020
1813,46020
1813,44862
2493,44862
2493,43617
2321,43617
2321,42430
2611,42430
2611,41152
2391,41152
2391,40031
3016,40031
3016,38816
3168,38816
3168,37657
3556,37657
3556,36624
4359,36624
4359,35231
3961,35231
3961,34126
4512,34126
4512,33010
5012,33010
5012,31914
5549,31914
5549,30782
5995,30782
5995,29877
6931,29877
6931,28750
7371,28750
7371,27478
7547,27478
7547,26548
8377,26548
8377,25638
9214,25638
9214,24112
9053,24112
9053,23078
9714,23078
9714,22544
11086,22544
11086,21315
11456,21315
11456,20475
12356,20475
12356,19659
13271,19659
13271,18667
13970,18667
13970,17259
14223,17259
14223,16823
15542,16823
15542,15619
16055,15619
16055,14805
16970,14805
16970,14058
17942,14058
17942,13467
19040,13467
19040,12958
20188,12958
20188,11496
20587,11496
20587,11082
21803,11082
21803,10241
22702,10241
22702,9851
23906,9851
23906,8932
24765,8932
24765,8868
26139,8868
26139,7628
26834,7628
26834,7179
27979,7179
27979,6608
29058,6608
29058,6132
30182,6132
30182,5897
31407,5897
31407,4952
32338,4952
32338,5188
33728,5188
33728,4766
34860,4766
34860,4099
35920,4099
35920,3577
37037,3577
37037,3198
38200,3198
38200,3484
39518,3484
39518,3138
40681,3138
40681,3177
41916,3177
41916,2437
43024,2437
43024,2285
44232,2285
44232,1805
45409,1805
45409,1997
46652,1997
46652,1708
47860,1708
47860,1841
49087,1841
49087,1594
50309,1594
50309,2106
51519,2106
51519,2058
52738,2058
52738,1966
53966,1966
53966,2505
55136,2505
55136,2336
56380,2336
56380,2580
57574,2580
57574,2857
58760,2857
58760,2730
60029,2730
60029,3421
61122,3421
61122,3902
62250,3902
62250,4274
63400,4274
63400,4367
64638,4367
64638,4601
65842,4601
65842,5080
66963,5080
66963,5654
68043,5654
68043,5981
69223,5981
69223,6400
70371,6400
70371,7257
71306,7257
71306,7591
72498,7591
72498,8201
73550,8201
73550,8781
74620,8781
74620,9577
75555,9577
75555,10299
76530,10299
76530,10753
77690,10753
77690,11565
78602,11565
78602,12232
79622,12232
79622,13007
80559,13007
80559,13953
81346,13953
81346,14655
82345,14655
82345,15256
83451,15256
83451,16393
84038,16393
84038,17386
84750,17386
84750,18236
85611,18236
85611,19061
86508,19061
86508,20065
87194,20065
87194,20596
88491,20596
88491,22004
88639,22004
88639,22938
89414,22938
89414,23814
90289,23814
90289,24788
91029,24788
91029,26054
91278,26054
91278,27083
91915,27083
91915,27942
92892,27942
92892,28921
93674,28921
93674,30316
93570,30316
93570,31326
94293,31326
94293,32527
94565,32527
94565,33724
94822,33724
94822,34633
95912,34633
95912,35867
96072,35867
96072,37131
96085,37131
96085,38183
96868,38183
96868,39344
97288,39344
97288,40571
97413,40571
97413,41788
97564,41788
97564,43033
97498,43033
97498,44296
97190,44296
97190,45426
98016,45426
98016,46666
97801,46666
97801,47894
97514,47894
97514,49086
98205,49086
98205,50305"""
part1_asserts = [
    (inp, 4763509452),
]
part2_asserts = [
    (inp, 1516897893),
]


@dataclass(frozen=True)
class Pos:
    x: int
    y: int

    def __add__(self, other):
        return Pos(self.x + other.x, self.y + other.y)

    def __lt__(self, other):
        return (self.x, self.y) < (other.x, other.y)

    def __eq__(self, other):
        return isinstance(other, Pos) and (self.x, self.y) == (other.x, other.y)


def is_vertical(line):
    return line[0].x == line[1].x


def is_point_on_line(p, line):
    if is_vertical(line):
        return p.x == line[0].x and min(line[0].y, line[1].y) <= p.y <= max(line[0].y, line[1].y)
    else:
        return p.y == line[0].y and min(line[0].x, line[1].x) <= p.x <= max(line[0].x, line[1].x)


def get_crossing_point(line1, line2):
    if is_vertical(line1) == is_vertical(line2):
        return None
    if is_vertical(line1):
        p = Pos(line1[0].x, line2[0].y)
    else:
        p = Pos(line2[0].x, line1[0].y)
    if is_point_on_line(p, line1) and is_point_on_line(p, line2):
        return p
    else:
        return None


class Point(NamedTuple):
    x: int
    y: int


def compute_area(p0, p1):
    dx = 1 + abs(p0.x - p1.x)
    dy = 1 + abs(p0.y - p1.y)
    return dx * dy


def generate_straight_line(p0, p1):
    if p0.x == p1.x:
        for y in range(min(p0.y, p1.y) + 1, max(p0.y, p1.y)):
            yield Point(p0.x, y)
    elif p0.y == p1.y:
        for x in range(min(p0.x, p1.x) + 1, max(p0.x, p1.x)):
            yield Point(x, p0.y)
    else:
        raise ValueError("Only horizontal or vertical lines are supported")


def part1(inp: str) -> str | int | None:
    result = 0
    corners = []
    edges = []
    for line in inp.splitlines():
        x, y = (int(z) for z in line.split(','))
        corners.append(Pos(x, y))
    for it, corner in enumerate(corners):
        if it == len(corners)-1:
            edges.append((corner, corners[0]))
        else:
            edges.append((corner, corners[it+1]))
    for p1 in corners:
        for p2 in corners:
            if p2 == p1:
                continue
            result = max(result,
                         (abs(p2.x - p1.x) + 1) * (abs(p2.y - p1.y) + 1))
    return result


def part2(inp: str) -> str | int | None:
    result = 0
    reds = []
    for line in inp.splitlines():
        x, y = map(int, line.split(','))
        reds.append(Pos(x, y))
    greens = []
    for p0, p1 in pairwise(chain(reds, [reds[0]])):
        for point in generate_straight_line(p0, p1):
            greens.append(point)
    decreasing_red_pairs = sorted(
        ((compute_area(*pair), pair) for pair in combinations(reds, r=2)),
        reverse=True,
    )

    y_lists = defaultdict(list)
    x_lists = defaultdict(list)

    for point in chain(reds, greens):
        y_lists[point.x].append(point.y)
        x_lists[point.y].append(point.x)

    for y_list in y_lists.values():
        y_list.sort()
    for x_list in x_lists.values():
        x_list.sort()

    def remove_adjacent(coords):
        filtered = []
        prev = None
        for c in coords:
            if prev is None or c - prev > 1:
                filtered.append(c)
            elif filtered:
                filtered.pop()
            prev = c
        return filtered

    for x in y_lists:
        y_lists[x] = remove_adjacent(y_lists[x])
    for y in x_lists:
        x_lists[y] = remove_adjacent(x_lists[y])

    def contains_rectangle(p0, p1):
        x_min = min(p0.x, p1.x) + 1
        x_max = max(p0.x, p1.x) - 1
        y_min = min(p0.y, p1.y) + 1
        y_max = max(p0.y, p1.y) - 1

        if bisect(y_lists[x_min], y_min) != bisect(y_lists[x_min], y_max):
            return False
        if bisect(y_lists[x_max], y_min) != bisect(y_lists[x_max], y_max):
            return False
        if bisect(x_lists[y_min], x_min) != bisect(x_lists[y_min], x_max):
            return False
        if bisect(x_lists[y_max], x_min) != bisect(x_lists[y_max], x_max):
            return False
        for y in range(y_min, y_max + 1):
            if bisect(x_lists[y], x_min) != bisect(x_lists[y], x_max):
                return False
        for x in range(x_min, x_max + 1):
            if bisect(y_lists[x], y_min) != bisect(y_lists[x], y_max):
                return False
        if bisect(x_lists[y_max], x_max) % 2 == 0:
            return False

        return True

    for area, pair in decreasing_red_pairs:
        if contains_rectangle(*pair):
            result = area
            break
    return result
